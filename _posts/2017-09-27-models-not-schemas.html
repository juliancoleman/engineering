---
title: Models !== Schemas
layout: default
permalink: /:year/:month/:day/:title
tags: resources
---

<div class="mdc-typography">
  <div class="mdc-layout-grid max-width">
    {% include post-header.html %}

    <div class="mdc-layout-grid__inner" style="grid-gap: unset;">
      <div class="mdc-layout-grid__cell mdc-layout-grid__cell--span-8 mdc-layout-grid__cell--span-8-tablet">
        <h2 class="mdc-typography--headline mdc-theme--primary" style="font-weight: 400;">
          Intro
        </h2>

        <p class="mdc-typography--body-1">
          Well, I can't believe I even have to write a post about this
          one. Back in late 2016 to just before the summer of 2017,
          the company I worked for gave me the task of building an app
          that essentially the business ran on. This app handled all
          the finances&mdash;paying employees, charging students, etc.
          &mdash;as well as a number of really important things that
          allowed our company to run and function as a business. If
          this app ever went down, we could lose between $80,000 to
          $1.5M in a very short time. For the sake of anonymity and
          respect for those involved, I won't name the company, and
          I'll dub the project <code>Purple Buddy</code>.
        </p>

        <p class="mdc-typography--body-1">
          I'll be comparing why these two are often confused and how
          to not be so confused next time you're working on a project
          where this argument arises. Our comparison will include
          <code>MongoDB</code>, versus <code>Bookshelf</code> and
          <code>Knex</code>.
        </p>

        <h2 class="mdc-typography--title mdc-theme--primary" style="font-weight: 400;">
          Models
        </h2>

        <p class="mdc-typography--body-1">
          Let's take a minute to talk about what a <code>Model</code>
          is. The best way that I could define a model is similar to
          actually looking at a <em>clay model.</em> The model has
          curves and edges, personality, and a shape. It has
          <em>structure.</em> Everything that can be known about the
          model can be seen superficially, as well as have some
          visceral mechanics that aren't seen. These are often
          represented by <code>virtuals</code>, <code>methods</code>,
          and <code>relations</code>. While they pertain to the model
          itself, models are really just <em>prototypes</em>, similar
          to <code>classes</code> or <code>primitives</code> in
          JavaScript. Their shape is inherited and extended with each
          generation.
        </p>

        <h2 class="mdc-typography--title mdc-theme--primary" style="font-weight: 400;">
          Schemas
        </h2>

        <p class="mdc-typography--body-1">
          Now that we've covered what a <code>Model</code> is, let's
          switch gears to <code>Schema</code>s. A schema is a set of
          column names with their associated types, and we can refer to
          it as blueprints for a table which lay out the properties of
          our models. These might be properties like a name, age, or
          hair color. When you look at a human being, you are looking
          at creation, equal in worth yet unique in the purpose he or
          she serves. This human being has a set of attributes. Their
          eyes tell the meaning of life. The model is the molded clay,
          the schema is the attributes for that model.
        </p>

        <h2 class="mdc-typography--title mdc-theme--primary" style="font-weight: 400;">
          The <em>Purple Buddy</em> project
        </h2>

        <p class="mdc-typography--body-1">
          I worked on <em>Purple Buddy</em> with one other person;
          together, we made up a team. We had no scope of work, but we
          did have an idea of what the app was supposed to do: to
          authenticate different types of admin users, show sidebar
          items based on their role, and redirect to a <code>403</code>
          page if they didn't possess the proper role to access that
          route. The rest of the operations were simple CRUD, which I
          won't get into much detail on.
        </p>

        <p class="mdc-typography--body-1">
          Our project had been re-adapted several times and the
          company had invested just shy of $1M, paying developers to
          make this beast how they envisioned it would be. You could
          think of this project like a collection of APIs in one,
          unified API. By the end of this, we should have been able to
          send emails, take payments, do much of our financial
          advisory, monitor roles, enroll our students, assign
          instructors to classrooms, and a number of other things. It
          was <em>YUGE</em>. But the company wanted something
          different. Their current implementation was something like
          26 SQL tables, a monstrosity of PHP code, and really...
          didn't <em>actually</em> work. So we had to find a way to
          combine certain tables, or make the data more efficient, as
          well as make the application work. Two guys, one massive
          project.
        </p>

        <p class="mdc-typography--body-1">
          In the beginning of this project, I had made the suggestion
          to use the <a href="https://hapijs.com">Hapi</a> framework
          for our API. It even had a builtin renderer, so Express
          wasn't a valid argument, it was just another suggestion. My
          suggestion was immediately shot down without consideration
          by both my teammate and our project manager at the time.
          Because we had the option to build it our way, I wanted to
          just build it properly from the start, not having to jump
          through hoops. Our company already invested so much, and I
          wanted to give them their money's worth.
        </p>

        <p class="mdc-typography--body-1">
          My teammate, however, suggested using Express and MongoDB.
          My reaction could be very closely related to that
          <a href="https://media.giphy.com/media/qmfpjpAT2fJRK/200.gif">
          gif of Tony Stark rolling his eyes</a>. In my defense, since
          I had worked in Hapi so much, I had much more confidence in
          it than I had in Express. I even went so far to make a
          <a href="https://github.com/juliancoleman/js-hapi-api">
          standardized API using Hapi</a>. But in my teammate's
          defense, he only really had some experience in Express, so I
          figured it'd be easy to roll with what he knew so that we
          wouldn't really be wasting any time. So we decided our stack
          would be Express, MongoDB, Mongoose, and... that's it, I
          think.
        </p>

        <h2 class="mdc-typography--title mdc-theme--primary" style="font-weight: 400;">
          Mongoose
        </h2>

        <p class="mdc-typography--body-1">
          Mongoose is a MongoDB object modeling tool designed to work
          in an asynchronous environment. Not like that last part
          matters unless you're getting down in the nitty-gritty, but
          this is the definition that can be found
          <a href="http://mongoosejs.com/docs/2.7.x/">here</a>. Now,
          as you're reading that post, we run into our first problem.
          Mongoose tells us that defining a model is as easy as:
        </p>

{% highlight javascript %}
var Comments = new Schema({
    title     : String
  , body      : String
  , date      : Date
});

var BlogPost = new Schema({
    author    : ObjectId
  , title     : String
  , body      : String
  , buf       : Buffer
  , date      : Date
  , comments  : [Comments]
  , meta      : {
      votes : Number
    , favs  : Number
  }
});

var Post = mongoose.model('BlogPost', BlogPost);
{% endhighlight %}

        <p class="mdc-typography--body-1">
          The first thing you may have noticed is that we are defining
          a <code>model</code>, but we are saying <code>new Schema</code>.
          Your first mistake may be that you're using Mongoose, but
          that's besides the point. Finally, on the last line, we can
          see that we're creating a <code>mongoose.model</code> with
          the schema, <code>BlogPost</code>. The code above implies
          that models and schemas are the same, but <em>you'd be
          wrong.</em>
        </p>

        <h2 class="mdc-typography--title mdc-theme--primary" style="font-weight: 400;">
          Bookshelf and Knex
        </h2>

        <p class="mdc-typography--body-1">
          It's actually very funny how unpopular these two libraries
          are. Knex is a kind-of port from the Laravel library called
          the <i>Laravel Query Builder</i>. It allows users to build
          complex queries in JavaScript, which translate to raw SQL.
          The benefit of using this library is that you don't have to
          have a bunch of SQL files in your project. You can just have
          your configuration and migrations and you're done.
        </p>

        <p class="mdc-typography--body-1">
          Bookshelf is a SQL ORM for NodeJS. We will be using
          Bookshelf to not only set up a connection to our database,
          but we will also use it for our <code>Model</code>s.
          Consider the following code to define our models.
        </p>

{% highlight javascript %}
// models.js

const BaseModel = Bookshelf.Model.extend({
  hasTimeStamps: true,
  softDelete: true,
  initialize(...args) {
    // some sample code
  },
  parse(attrs) {
    // some sample code
  },
  format(attrs) {
    // some sample code
  },
  fetch(options) {
    // some sample code
  },
  destroy(options) {
    // some sample code
  }
});

const UserModel = Bookshelf.model("User", BaseModel.extend({
  tableName: "users",
  customError: UserNotFoundError,
  virtuals: {
    groupMembers() {
      // some sample code
    }
  }
  authorize(user) {
    // some sample code
  },
  roles() {
    return this.hasMany("Role");
  },
}));
{% endhighlight %}

        <p class="mdc-typography--body-1">
          Next, we will define our <code>schema</code>.
        </p>

{% highlight javascript %}
// 20170907091929_create_users.js

exports.up = knex =>
  knex.schema.createTable("users", (table) => {
    table.increments();
    table.string("email_address");
    table.string("password");
    table.timestamps();
    table.timestamp("deleted_at");
  });

exports.down = knex =>
  knex.schema.dropTable("users");
{% endhighlight %}

        <p class="mdc-typography--body-1">
          As you can see by the two snippets above, there is a great
          separation of concern between what a <code>schema</code> is,
          and what a <code>model</code> is. The schema is the design
          of the table, and their associated value types; the model is
          the core functionality of the table it belongs to, as well
          as custom methods, relations, virtuals, etc. This separation
          caused a great many arguments between my teammate and myself,
          that of which I'm not proud of. If you're on a team, you
          should always be willing to sacrifice. And if you feel like
          your way is better, make your case, and the rest of your
          team should have the willingness to listen and learn.
        </p>

        <h2 class="mdc-typography--title mdc-theme--primary" style="font-weight: 400;">
          Conclusion
        </h2>

        <p class="mdc-typography--body-1">
          In this post, I evaluated the differences between models and
          schemas. Models can be described as the <em>prototype</em>,
          whereas schemas can be described as a model's attributes. I
          compared MongoDB to Bookshelf and Knex, juxtaposing and
          contrasting each library's take on how data should be
          structured. It should be noted that Bookshelf and Knex
          require you to use a SQL database, whereas MongoDB is its
          own, NoSQL, "schemaless" database. I won't touch on why
          NoSQL is exceedingly bad practice, but if you're working
          with relational data, you should be using a relational
          database. Not a flipping Word document.
        </p>

        <p class="mdc-typoraphy--body-1">
          If you find yourself being one of those people who don't see
          the relevance of this post, or think Bookshelf and Knex
          <em>overcomplicate things</em>, you might want to
          re-evaluate being an engineer, or at least consider more
          training. I wrote this post due to an ever-present issue
          called
          <a href="https://www.crondose.com/2016/06/writing-bad-code-immoral/">
          immoral code</a>. My goal as an engineer is to make other
          engineers 10 times better at their job, so that they may
          teach other egineers to be 10 times better at their job, and
          so on.
        </p>
      </div>
    </div>
  </div>
</div>

